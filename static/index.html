<head>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://d3js.org/topojson.v3.min.js"></script>
    <style>

        .gridlines line{
            stroke: #bbb;
        }
        
        .grindline .domain{
            stroke: none;
        }
        
        </style>
</head>

<body>
        <svg id="plot" height="500" width="1200" style="margin-top:50px"> </svg>
        <script>
            //chart setup
            const svg = d3.select("svg#plot");
            const width = svg.attr("width");
            const height = svg.attr("height");
            const margin = {top: 20, right: 20, bottom: 20, left: 20};
            const chartWidth = width - margin.left - margin.right;
            const chartHeight = height - margin.top - margin.bottom;

            let annotations = svg.append("g").attr("id","annotations");

            const loadPlot = async function(){
                //load data
                let data = await d3.csv("./Street_Tree_List-2022-01-30_FILTERED.csv", d3.autoType)
                console.log("Tree data: ", data);
                const neighborhoodData = await d3.json("./SF-Neighborhoods.geo.json");
                console.log("Map data:", neighborhoodData);
                console.log("Map objects: ", neighborhoodData.objects);
                
                //map of SF
                const neighborhood = topojson.feature(neighborhoodData, neighborhoodData.objects.SFNeighborhoods); 
                const projection = d3.geoMercator().fitSize([chartWidth, chartHeight], neighborhood);
                const path = d3.geoPath().projection(projection);

                projection.fitSize([chartWidth, chartHeight], neighborhood);

                svg.selectAll("path")
                    .data(neighborhood.features)
                    .enter()
                    .append("path")
                    .attr("d", path)
                    .attr("fill", "white")
                    .attr("stroke", "black")
                    .attr("stroke-width", 0.5);

                //color scale for trees based on what group their caretaker falls into
                const caretakerCounts = {};
                const caretakerGroups = {
                    "Private": ["Private"],
                    "Public Safety & Infrastructure": ["Police Dept", "Fire Dept", "DPW", "Port", "Rec/Park", "PUC"],
                    "Government & Administrative Offices": ["Mayor's Office of Housing", "Office of Major", "Dept of Real Estate", "Purchasing Dept", "Health"],
                    "Arts & Culture": ["Asian Arts Commission", "War Memorial", "Arts Commission", "Public Library", "Housing Authority", "Mission Verde"],
                    "Schools": ["City College", "SFUSD"]
                };

                const groupColors = {
                    "Private": "#9370DB", //medium purple
                    "Public Safety & Infrastructure": "orange",
                    "Government & Administrative Offices": "pink",
                    "Arts & Culture": "red",
                    "Schools": "green",
                    "Unknown": "#4682B4" //medium blue
                };

                //groups
                const caretakerToGroup = {};
                Object.entries(caretakerGroups).forEach(([group, caretakers]) => {
                    caretakers.forEach(caretaker => {
                        caretakerToGroup[caretaker] = group;
                    });
                });

                const groupCounts = {};
                data.forEach(d => {
                    const caretaker = d.qCaretaker || "Unknown";
                    const group = caretakerToGroup[caretaker] || "Unknown";
                    groupCounts[group] = (groupCounts[group] || 0) + 1;
                });

                //individual caretakers
                data.forEach(d => {
                    const caretaker = d.qCaretaker || "Unknown";
                    caretakerCounts[caretaker] = (caretakerCounts[caretaker] || 0) + 1;
                });

                const caretakerTypes = Object.keys(caretakerCounts);
                const colorScale = d3.scaleOrdinal()
                    .domain(caretakerTypes)
                    .range(d3.schemeCategory10);

                //plot trees
                svg.selectAll("circle")
                    .data(data)
                    .enter()
                    .append("circle")
                    .attr("cx", d => {
                    if (d.Longitude && d.Latitude) {
                        const coords = projection([d.Longitude, d.Latitude]);
                        return coords ? coords[0] : null;
                    }})
                    .attr("cy", d => {
                        if (d.Longitude && d.Latitude) {
                            const coords = projection([d.Longitude, d.Latitude]);
                            return coords ? coords[1] : null;
                        }})
                        .attr("r", 1)
                        .attr("fill", d => {
                            const caretaker = d.qCaretaker || "Unknown";
                            const group = caretakerToGroup[caretaker] || "Unknown";
                            return groupColors[group];
                        })
                        .attr("opacity", 0.5);

                const legend = svg.append("g").attr("transform", "translate(10, 10)");

                // caretakerTypes.forEach((type, i) => {
                //     legend.append("circle")
                //         .attr("cx", 0)
                //         .attr("cy", i * 15)
                //         .attr("r", 5)
                //         .attr("fill", colorScale(type));

                //     legend.append("text")
                //         .attr("x", 10)
                //         .attr("y", i * 15 + 5)
                //         .text(type)
                //         .attr("font-size", "10px")
                //         .attr("alignment-baseline", "middle");
                // })

                // caretakerTypes.forEach((type, i) => {
                //     legend.append("circle")
                //         .attr("cx", 0)
                //         .attr("cy", i * 15)
                //         .attr("r", 5)
                //         .attr("fill", colorScale(type));

                //     legend.append("text")
                //         .attr("x", 10)
                //         .attr("y", i * 15 + 5)
                //         .text(`${type}: ${caretakerCounts[type]} trees`)
                //         .attr("font-size", "10px")
                //         .attr("alignment-baseline", "middle");
                // })
                Object.entries(groupCounts)
                    .sort((a, b) => b[1] - a[1])
                    .forEach(([group, count], i) => {
                        legend.append("circle")
                            .attr("cx", 0)
                            .attr("cy", i * 20)
                            .attr("r", 5)
                            .attr("fill", groupColors[group]);

                        legend.append("text")
                            .attr("x", 10)
                            .attr("y", i * 20 + 5)
                            .text(`${group}: ${count || 0} trees`)
                            .attr("font-size", "12px")
                            .attr("alignment-baseline", "middle");
                });
            };
            loadPlot();
            
        </script>
</body>